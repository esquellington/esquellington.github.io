* Intro
The MF-Set / union-find is one of my favourite algorithms (LINK wikipedia)

I've implemented it like 6 or 7 times,

* Idea
The basic idea is

** Set
given the set of integers 0..N-1, manage its subsets
- Each element in exactly 1 subset
- There is no empty subset

MF-Set Ops:
- Add element
- Merge 2 sets
- Lookup set that contains a given element
- Enumerate disjoint subsets
- Enumerate elements in a disjoint subset

** Graph
ALTERNATIVELY: A Graph with N nodes and E undirected edges, find the Connected Components
Nodes = Set elements
Edges = Merge ops
CC = disjoint subset

** General
ASSUME elements[i] indexed by i \in 0..N-1
Explain how this maps to indices of any array<T>

* Applications
** Graph connected components/clustering (LINK wikipedia?)
** RBD partitions (LINK Bullet)
   - Independent computation
     - Parallelisation
     - Per-partition convergence analysis & sleeping
** Mesh CC (LINK geoproc?)
   - high level reasoning/edition
   - Ex: Split mesh into its CC
     - IsConnected?
     - For CD/BVH
     - For compression
** Reconstruct an Intersection Curve from unsorted Segments LINK thesis
   - using prev/next INDEXES as intrusive list!
   - reuse this idea for O(1) online enumeration
     - May need next/last, instead of prev, to append lists in O(1)

** Kruskal alg to compute MinSpanningTree
   - Reason about structure, depth, complexity...
** Matrix partitioning/parallelization??
   - POTSER es podria aplicar a la idea de fons que tinc de
     Partitioned Dynamics amb convergencia/freqs adaptatives per
     partition??
   - METIS sembla que usa idea semblant, veure
     http://cgi.cs.arizona.edu/~mstrout/Papers/Papers12/lcpc2012-parcubed.pdf
   - En aquesta tesi
     http://dspace.uib.no/bitstream/handle/1956/5118/Dr.thesis_Mostofa_Ali_Patwary.pdf?sequence=1&isAllowed=y
     en parlen amb detall, SI, es pot usar per a això!
     - "Another application of the Union-Find algorithm is the
       computation of an 12 elimination tree from a sparse, symmetric,
       and positive definitematrix in numer- ical linear algebra [86,
       144]. The elimination tree provides structural information
       relevant to the sparse factorization process [87, 110]. The use
       of the elimination tree includes, among others, finding
       equivalent matrix reorderings [108], various sparse storage
       schemes [86], and symbolic factorization [60]. The elimination
       tree is usually defined through the Cholesky factor (in which,
       nonzero elements above the diagonal have been transformed to be
       equal to zero) [59]. However, to con- struct the elimination
       tree directly from the sparse matrix efficiently, different
       variations of Union-Find algorithms have been tried and found
       to be efficient"
** Mfset == minimitzar autòmats?? Util per reduir FSA
* DataStructure/Algorithms
* Rem's algorithm
  Sembla que es una variant MES RAPIDA que mfset amb PC i RK, que es
  "l'optim teòric"
    - http://www.ii.uib.no/~fredrikm/fredrik/papers/SEA2010.pdf
    - 2010_ExperimentsOnUnionFindAlgorithms
  - Interleave Find(n1), Find(n2) ? no ho entenc massa be, pero
    sembla que troba rapidament el cas en que n1 i n2 ja son fills
    del mateix root, però no han estat encara comprimits del tot.
* DONE Algorithmic Optimizations
** DONE Path-compression
  - Recursive
  - Iterative
** DONE MS2L: Merge-smaller-to-larger
  - Computing "size"
** TODO Cost Analysis
*** Ackerman??

* DONE Enumerating set elements
** DONE Online: O(1)
  - Merge with linked-lists of bucket-lists, done in CRS Partitions
** DONE Post-process:
  - Foreach n == Find(n) do Create CC if new and Add-to-CC always
* DONE Enumerating sets
** DONE Online:
  - Embed prev_root/next_root into entries, init list to contain ALL
    nodes, but remove when merged-to
** DONE Post-process
  - Foreach n == Find(n)
* TODO Adding Nodes
- Extend array, O(1) if no realloc, use 2x size FTW
* TODO Removing Nodes
- Potential set Split
- Do NOT contract array<Node> to preserve node ids, instead, mark
  Node as "empty", and LINK IT into an empty node list using
  m_Pred/m_Succ list-CC that is not in use for empty nodes.
* TODO Removing Edges
- Potentiall set Split
- MST-edges
- \todo Search for specific structure (bullet forum mentions it)
DeleteEdge e = (n1,n2)
- NOMES afecta a root(n1)
- Es pot fer rebuild parcial
- Nomes si e no és MST-edge
  - MST-edges es podrien guardar en llista incrustada
Veure paper http://dl.acm.org/citation.cfm?id=545384
* TODO Storing edges
** Edges
   - MFSet edge-array 0..E-1
   - Edge = n1,n2,pred_edge_in_cc,succ_edge_in_cc
   - Ideally, 1 bit to store IsMST
** Nodes
   - Roots need a ptr to First/Last Edge index to merge edges-in-CC
     lists in O(1)
   - Could add first_edge,last_edge to Node... but that'd grow to
     6*uint32 per Node, TOO BIG
     - non-root m_Pred/m_Succ are UNUSED
     - a root can only have 0 children if it has also 0 edges (root,n_i)
     - any root with >0 edges also has >0 children
     - THEREFORE the non-root node root.m_Next has UNUSED
       m_Pred/m_Succ, which CAN BE USED as first_edge/last_edge
** PRIORITY: KEEP Node and Edge <= 128b
* TODO Rebuild single CC
- Use embedded list of nodes and edges to rebuild it from scratch
- INSTEAD of rebuild on remove edge/node, we can FLAG root as DIRTY
  (another bit we have to alloc somewhere) and rebuild the CC
  on-access
  - This way, consecutive removals will lead to a SINGLE Rebuild() on
    the next access, not for each one!
* Demo
** Basic
** Path-Compression
** MS2L
* Benchmarks
** Add: Add N nodes, Add E random edges
** Add_Enumerate: Add N + Add E + Enumerate
** Add_Enumerate_Interleaved: Add N + E * (Add e + Enumerate)
** Add_Remove_Enumerate: Add N + R * (Add E + Remove R) + Enumerate
** TODO Enumerate All N=8, E=0..K_8 graphs
   - 8x8 = 64 parells, 2^64 bits representen tots els grafs possibles
   - MOLTS menys, en realitat, pq adj-matrix és simetrica i té
     diagonal a 0 forçosament
   - 2^64 continua sent MASSA... veure so es pot generar tots els
     grafs d'N nodes de forma sistematica i sense simetries?
* Plots
** Increase N, E and R in Benchmarks
** Real cost Vs Theoretical cost

* Profiling & Optimization
  - Use perf
  - Try to improve it
* Optimizations
** Space
   - Mergint to smallest-root allows m_Parent to be used as m_Last for
     roots, saving additional m_Last attrib
   - Allows embedding root-list and keep node size <= 128b
** Cache
   - Sort lists incrementally whenever accessed by swapping
     neighbours, costs O(1) per access but average/amortized cost
     should improve
   - list-CC
   - list-nodes-in-CC
   - list-edges-in-CC
** Tradeoffs
   It's reasonable to keep track of
   - list-nodes-in-CC
   - list-CC
   if the algorithm is used incrementally and CC persistence is
   required (ex: CRS islands) by the user to enable other
   optimizations Otherise, the cost of initialization and update of
   next/last and pred/succ may exceed any O(N) cost of rebuilding the
   lists when required/on access.
** Alloc/Dealloc
   - Single vector with nodes-in-CC organized in subarrays per-CC can
     be build in a 2-pass count-and-classify alg.
** Comparison
- Comparar amb single-shot flood alg foreach(n) -> flood and gather accessible if not already flooded
- Per a CC single-shot es més eficient, imagino
- Per incremental no crec
- REQUREIX relacio node->arestes[]

* Beyond
** Weighted edges, strong CC ?
** Directed edges?
